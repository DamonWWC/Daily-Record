1. 多线程是并发的一种形式，并行处理的多线程的一种形式，异步编程是并发的一种形式，采用future模式或回调（callbaclk）机制，以避免不必要的线程。
2. 异步编程两大好处：1、提高响应能力。2、实现了可扩展行。
3. 不要用void作为async方法的返回类型，仅仅限于编写事件处理程序。
4. 多线程的主要实现方式，：1、使用Thread类，适用于对线程生命周期需要精细控制的场景，灵活性高，可以完全控制线程，缺点是需要手动管理线程的创建、销毁，容易引发资源浪费和死锁。2、线程池，通过复用线程提升性能，适用于轻量级的任务，优点是性能高，线程池自动管理线程，缺点不适合长期运行的任务。
                         3、Task,是TPL(数据流)的核心类，提供了更高层次的并发抽象。结合async/await，可以轻松实现异步操作，优点是代码整洁，适合CPU密集型任务和I/O密集型任务。4、Parallel类和PLINQ。
5. 同步的类型包括两种：通信和数据保护。当一段代码吧某些情况通知给另一段代码时，用的是通信。
6. 同步共享数据需要满足三个条件：1、多段代码正在并发运行。2、这几段代码在访问（读或写）
7.lock关键字需要同一个线程中获取锁和释放锁。 lock语句与await不兼容，如果多个代码块需要安全的读写共享数据，并且这些代码块可能使用await语句，可使用SemaphoreSlim类。private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1); await _semaphore.WaitAsync(); // 等待获取信号量 _semaphore.Release(); // 释放信号量
8. 阻塞信号，常用的跨线程信号的方式是使用ManualResetEvent类。
9. 高度并发的代码，如果太高，需要方法对并发性进行限流。并发程度太高是指程序中的一部分无法跟上另一部分的速度，导致数据事项积累并消耗内存，这种情况下对部分代码进行限流，避免占用太多内存。
10. 调度器（scheduler）是一个确定代码运行地点的对象。
11. ThreadStaticAttribute用于标记一个静态字段，使得每个线程都有该字段的独立副本。避免多线程同时访问和修改同一个静态变量时可能出现的并发问题。
12. 死锁：两个共享相同资源的程序或线程执行实际上相互阻止访问资源，导致两者同时被阻止并停止执行的情况。
13. 争用条件：如果两个或多个线程访问相同的对象，并且对共享状态的访问没有同步，就会出现争用条件。
14. readonly只读队列，只能在初始化时赋值，后续不能修改，主要限制了队列引用的修改，即不能将一个新队列对象重新赋值给这个队列，但是对于队列内部元素的操作（如入队、出队等）并没有限制，队列本身的内容是可以改变的。
15. Immutable不可变队列是一种数据结构上的概念，它确保队列一旦创建，其内容就不能被修改，任何修改队列的操作，实际上是返回一个新的队列，而原始队列保持不变。
16. 阻塞队列（BlockingCollection<T>）：一个线程正在装载数据，装载的同时把数据压进管道，与此同时，零一个线程在管道的接收端接收并处理数据。
17. Interlocked类用于使变量的简单语句原子化，提供了以线程安全的方式递增、递减、交换和读取值的方法。
18. Monitor类的主要优点是：可以添加一个等待被锁定的超时值。
19. Semaphore类（信号量）：是一种计数的互斥锁定。可以同时由多个线程使用。信号量提供了两个类，分别是Semaphore和SemaphoreSlim，semaphoreSlim类比semaphore类更轻量级，是对较短等待时间进行了优化的轻型版本。
20. Event类：提供了ManualResetEvent,AutoResetEvent,ManualResetEventSlim,CountdownEvent类。
21. Barrier类：非常适用于其中工作有多个任务分支且以后又需要合并工作的情况。
22. ReaderWriterLockSlim类：提供了一个锁定功能，如果没有写入器锁定资源，就允许多个读取器访问资源，但只能有一个写入器锁定资源。EnterReadLock(),TryEnterReadLock(),EnterWriteLock(),TryEnterWriteLock()