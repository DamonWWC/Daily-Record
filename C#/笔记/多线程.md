1. 多线程是并发的一种形式，并行处理的多线程的一种形式，异步编程是并发的一种形式，采用future模式或回调（callbaclk）机制，以避免不必要的线程。
2. 异步编程两大好处：1、提高响应能力。2、实现了可扩展行。
3. 不要用void作为async方法的返回类型，仅仅限于编写事件处理程序。
4. 多线程的主要实现方式，：1、使用Thread类，适用于对线程生命周期需要精细控制的场景，灵活性高，可以完全控制线程，缺点是需要手动管理线程的创建、销毁，容易引发资源浪费和死锁。2、线程池，通过复用线程提升性能，适用于轻量级的任务，优点是性能高，线程池自动管理线程，缺点不适合长期运行的任务。
                         3、Task,是TPL(数据流)的核心类，提供了更高层次的并发抽象。结合async/await，可以轻松实现异步操作，优点是代码整洁，适合CPU密集型任务和I/O密集型任务。4、Parallel类和PLINQ。
5. 同步的类型包括两种：通信和数据保护。当一段代码吧某些情况通知给另一段代码时，用的是通信。
6. 同步共享数据需要满足三个条件：1、多段代码正在并发运行。2、这几段代码在访问（读或写）
7. lock语句与await不兼容，如果多个代码块需要安全的读写共享数据，并且这些代码块可能使用await语句，可使用SemaphoreSlim类。private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1); await _semaphore.WaitAsync(); // 等待获取信号量 _semaphore.Release(); // 释放信号量
8. 阻塞信号，常用的跨线程信号的方式是使用ManualResetEvent类。
9. 高度并发的代码，如果太高，需要方法对并发性进行限流。并发程度太高是指程序中的一部分无法跟上另一部分的速度，导致数据事项积累并消耗内存，这种情况下对部分代码进行限流，避免占用太多内存。
10. 调度器（scheduler）是一个确定代码运行地点的对象。
11. ThreadStaticAttribute用于标记一个静态字段，使得每个线程都有该字段的独立副本。避免多线程同时访问和修改同一个静态变量时可能出现的并发问题。
12. 死锁：两个共享相同资源的程序或线程执行实际上相互阻止访问资源，导致两者同时被阻止并停止执行的情况。
13. readonly只读队列，只能在初始化时赋值，后续不能修改，主要限制了队列引用的修改，即不能将一个新队列对象重新赋值给这个队列，但是对于队列内部元素的操作（如入队、出队等）并没有限制，队列本身的内容是可以改变的。
14. Immutable不可变队列是一种数据结构上的概念，它确保队列一旦创建，其内容就不能被修改，任何修改队列的操作，实际上是返回一个新的队列，而原始队列保持不变。
15. 阻塞队列（BlockingCollection<T>）：一个线程正在装载数据，装载的同时把数据压进管道，与此同时，零一个线程在管道的接收端接收并处理数据。
16. 